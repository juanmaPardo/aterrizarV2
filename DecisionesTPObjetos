Creamos la clase abstracta Aerolinea, porque no vamos a necesitar instanciar ningun objeto de esta clase ya que las dos Aerolineas que vamos a tener que instanciar son Oceanic y Lanchita, las cuales van a heredar de Aerolinea. La clase Aerolinea va a tener una lista de Vuelos, una lista de asientos que estan comprados, un diccionario de asientos vendidos segun el vuelo, donde la clave va a ser el numero de vuelo y el valor va a ser la cantidad de asientos vendidos de ese vuelo. Tambien va a tener dos constantes, una de recargo que va a depender de cada aerolinea, y otra que indica los dias hasta que expire la reseva. Los metodos que va a tener aerolinea so los getter y setter de todos sus atributos junto a otros metodos para obtener informacion acerca de los asientos o realizar alguna operacion con los asientos. Los metodos abstractos que va a tener van a ser implementados por las aerolineas que hereden de la clase Aerolinea que las vamos a explicar mas adelante.

Luego creamos la clase AerolineaLanchitaI la cual va a servir para comunicarse con el sistema, es decir, el sistema se va a poder comunicar con la aerolineaLanchita a traves de AerolineaLanchitaI. La clase AerolineaLanchita va a heredar de la clase Aerolinea, para poder compartir el comportamiento que tienen en comun, y los comportamientos distintos que tenga, se van a "overridear" en los metodos, para poder aplicar los comportamientos particulares que esta tenga. El metodo setearAsiento() va a parsear el asiento para que sea de tipo Asiento, este le va a venir de una lista de listas de asientos en formato string, y la posicion de esa lista, es decir el asiento que quiera parsear, y va a devolver un asiento parseado en tipo Asiento. 

La clase AerolineaOceanic es muy parecida a Lanchita, ya que tambien va a haber una clase AerolineaOceanicI para que el sistema se pueda comunicar con Oceanic. En AerolineOceanic va a haber una diferencia en los codigo de ciudad, es por eso que va a haber un metodo convertirFormatoCiudad() que recibe un codigo de ciudad y lo transforma al formato que neceistaOceancic. La otra diferencia que va a haber es que el asiento va a tener mas informacion que el Asiento de lanchita. Es por eso que creamos la clase AsientoDTO en la que agregamos la informacion que solicitaba. En el metodo setearAsiento() va a parsear el asiento que viene en una lista de listas, pero en este caso lo va a parsear a AsientoDTO. El metodo asientosDisponibles va a recibir un Vuelo y un tipo de Requisito para devolver los asientos, el requisito puede ser Origen o OrigenYDestino, esto lo hicimos ya que Oceanic debe entender los metodos asientosDisponiblesParaOrigen y asientosDisponiblesParaOrigenyDestino.
De esta forma logramos que ambas aerolineas entiendan los mismos mensajes pero que cada una responda de manera particular a estos metodos, lo hicimos asi para que las aerolineas sean POLIMORFICAS.


La parte de los Asientos, pensamos en realizar una clase Asiento, la cual va a tener la informacion propia de cada asiento, como lo son la clase, el codigo, el estado, el precio y la ubicacion. Para darle diferentes funcionalidades al sistema, necesitabamos que todos estos atributos tengan comportamientos, es por eso que decidimos crear una clase para cada atributo donde en cada clase implementamos los comportamientos que deberian tener. Luego creamos el AsientoDTO, el cual va a ser utilizado por Oceanic, hicimos que AsientoDTO herede de Asiento porque tienen comportamiento en comun, pero ademas este tiene la informacion de la fechaDeSalida y la horaSalida, entonces le agregamos esas particularidades para que cumpla con los requisitos pedidos en el enunciado. 
En relacion a los asientos, la otra clase que creamos es el AsientoVueloFullData el cual va a tener la informacion propia del asiento, junto a la informacion del vuelo; esto lo hicimos ya que en la parte de Busquedas va a haber muchos filtros para corroborar que asientos cumples con esos filtros, y muchos de estos filtros no estan incluidos en Asiento, como pueden ser el filtro del destino, de la hora, del origen, etc. Entonces para reunir toda la informacion necesaria para aplicar los filtros dedicimos crear esta clase.


Para realizar las busquedas decidimos crear una interfaz que se va a llamar FiltroBusqueda, la cual va a tener un metodo asientoVueloCumpleParametro. Luego creamos todos las clases de filtros que hay para filtrar asientos como lo son FiltroCodigoAsiento, FiltroDestino, FiltroHora, FiltroPrecio, etc. Aca se puede ver la justificacion de porque utilizamos el AsientoVueloFullData, justamente para reunir toda la informacion necesaria para aplicarle a un asiento los filtros. En todas clases de filtros implementamos el metodo asientoVueloCumpleParametro con la condicion que debe cumplir el asiento para que se filtre correctamente. En la clase Busqueda, realizamos un constructor que va a poder recibir varios filtros de cualquier tipo justamente para poder aplicar una busqueda sin importar que filtro reciba ni la cantidad. Hay tres filtros que debe recibir obligatoriamente que son el origen, destino y fecha, es por eso que si en el constructor no se especifican esos filtros tira excepciones 

La clase Vuelo va a contener la lista de Asientos de ese vuelo, junto a la informacion propia del vuelo como son el origen, el destino, la fecha de salida, de llegada, hora de salida y hora de llegada. Va a contener un getter de cada uno de sus atributos y un metodo que nos va a permitir cargar los asientos al vuelo. 


Para la entrega 4 tuvimos que realizar las vistas para probar el funcionamiento del proyecto. Para realizar esto nos basamos en el MVC (Modelo Vista Controlador), lo que buscamos es separar a las vistas del modelo, utilizando un controlador; para esto lo que hicimos es que el controlador tenga una instancia de el/los modelo/s que vamos a utilizar; y luego que la vista tenga una instancia de del controlador. De esta manera se cumpliría con lo que indica el MVC, donde el controlador es como una especie de "puente" entre el modelo y la vista.

Empezamos con la vista de Bienvenida, la cual va a tener todos los listeners para que ante cualquier click en alguno de sus botones ocurra algun evento, esta vista tambien va a tener una instancia del controlador ControladorBienvenida el cual va a tener una instancia de Usuario, el cual va a ser nuestro unico modelo ya que la vista Bienvenida solamente necesita informacion del Usuario. De esta manera la vista conoce a el ControladorBienvenida, y este ultimo conoce al Usuario(modelo).
La vista de Bienvenida nos va a dar tres botones que al clickearlos se van a abrir otras nuevas vistas:

-Al precionar el boton "Ver Compras" o "Ver Reservas" se va a abrir la vista ReservaCompras, decidimos crear una sola vista tanto para las compras como para las reservas ya que el funcionamiento practicamente es el mismo y el diseño tambien, solo que en uno se obtienen las reservas y en otro se obtienen las compras de un usuario. En esta vista van a estar los metodos necesarios para poder rellenar las filas de las tablas, eliminar filas de tablas, etc. Para que cumpla con el MVC hicimos que la vista ReservaCompras tenga una instancia al ControladorCompraReservas, el cual va a tener una instancia al ModeloUsuario, ya que Usuario es nuestro unico Modelo para este caso. De esta forma el ControladorCompraReservas es el puente entre el ModeloUsuario y la vista ReservaCompras.

-Al precionar el boton "BuscarAsientos" se va a abrir la vista BusquedaAsientos, la cual va a tener todos los metodos necesarios para lograr realizar lo que el enunciado solicita y va a tener una instancia al ControladorBusquedas el cual va a tener una instancia al ModeloBusquedas, quien va a tener instancias a todos los modelos necesarios para poder realizar lo que se pide, en este caso son Usuario, Asiento, AterrizarV2. En este caso va a haber mas Modelos ya que se necesita mucha mas informacion que lo se pedia antes, y el Usuario solo habia muchas cosas que no conocia, es por eso que tuvimos que agregar mas modelos. Al igual que explique anteriormente, para lograr que se cumpla con el MVC, la vista va a tener una instancia del controlador, y este una instancia del modelo, justamente para que el controlador actue como puente entre la vista y el modelo. 




